The main gameplay loop of Hellboy involves traversing through procedurally generated levels in four distinct biomes. One of these biomes is a corrupted forest area that stands out among the other biomes due to the tall trees looming over the player and the
use of a large terrain as a foundation rather than simply being a collection of floating rooms and paths. While the area may look different from other biomes, the procedural generation method is identical in how it lays out the rooms except for an added step
of carving these levels out from a base terrain rather than building them in the scene. This meant that when it came to populating the out of bounds areas with trees we found ourselves with some problems to solve.

The Brief:
  - Trees should be able to spawn close enough to the play area to seem natural. While the easiest option would be to create a set of bounds for the entire playable area and stop trees from spawning in it, this would lead to huge gaps around playable rooms where no trees spawned, which would break immersion.
  - Forest should be dense enough to look imposing, but trees should not be able to clip into each other. This meant that we had to find a way to make sure trees didn't spawn with huge gaps between them, but also didn't spawn close enough to each other to clip.
  - Trees cannot spawn on the playable area. This meant that we needed to know all the boundaries of each room and path in order to not allow any trees to spawn inside one.
  - Cannot have a large impact on loading times. Procedurally generating levels with terrain already took much longer than levels without, so the tree spawning algorithm needed to be performant enough to avoid any major slowdowns, especially as the game would be released on the Nintendo Switch.

In order to fit the brief I knew that I eneded to find a way to calculate as many positions that could contain a tree as possible, but due to the size of the terrains being used it would take millions of iterations to check every individual coordinate. As such I decided that the best option would be to
divide the terrain into a grid and use the corners of the individual grid squares to check whether I could skip running any expensive calculations on the interior points. I could also solve the issue with overcrowding this way by only allowing one tree in each grid.

The tree placement system works by first assigning each point on the terrain a distance value representing how far away they are from the nearest point on the playable level. To avoid calculating this for every point on the terrain I separate the terrain into grids and check whether each corner of the grid is 
far enough away from every point in the level to meet our minimum specification. If they were then we could guarantee that every value within this grid would also meet this specification, and as such I would simply iterate through them and set their value to be the maximum value possible so that they would always
pass any distance tests. If any of the four corners were too close to the level then I would check each individual coordinate within the square to ensure a greater level of accuracy once the areas we were checking were close to the level itself.

To decide which positions the trees would be placed in I once again sampled the terrain as a grid, this time checking whether the top right and bottom left of each grid both were far enough away from the level to allow a tree to be placed in them. If they were, I would add every point within them to a list of valid
points inside of a ValidTreeGrid data type that could be stored into a list of valid grids that could be iterated through when placing trees. If either corner was too close to the level I would disregard the grid completely to avoid any chance of trees spawning somewhere that might impact the player's ability to progress.
Upon revisiting this code, I can see an error in the fact that I started the x and y values in the nested for loop at 0. This is wrong as the grid is created by using the current x and y values for the top right corner and the previous values as the bottom left. This means that on the first iteration both corners are 
identical. This also causes a problem when setting the minimum coordinate for this grid, as to avoid overlap I was setting this value to be the last x and y values + 1, which means that the minimum value would be higher than the maximum value. Fortunately this did not impact the final product as any values within this
range ended up being too far away from the actual level for the player to actually see once LODing had taken effect, but it would still be better if the x and y iterators started at the first step size.

Once I had a list of valid grids that trees could be placed on I could simply iterate through the grids and choose a random point on them to place a tree on. The mesh used for each tree instance was also randomly chosen from a list that could be populated in editor by the artists.
Ultimately I'm happy with how this system turned out as it produced the intended visual results while also being efficient enough to not impact loading times (when timing how long the process took the return value was a fraction of a second). I do feel that there are some improvements to be made, possibly by adding in an
extra layer of checks to stop trees being placed in areas that are so far away from the level you'd never see them as we currently waste time placing trees in the far corners of the terrain.
